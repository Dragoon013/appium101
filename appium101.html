<!doctype html>
 <html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Sauce Laboratories - Appium 101 </title>

		<meta name="description" content="Learn how to write and run a Appium script locally and with Sauce Labs">
		<meta name="author" content="Jacob Teal">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sauce.css" id="theme">

        <!--favicon-->
        <link rel="shortcut icon" href="assets/images/sauce_favicon.ico" type="image/x-icon" />
		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

	  <div class="reveal">

        <style>
          .reveal .slides { text-align: left; }
          .reveal .slides h1 { text-align: center; }
          .reveal .slides h2 { text-align: center; }
          .reveal .slides h3 { text-align: center; font-variant: none; text-transform: none;}
        </style>
		<!-- Any section element inside of this container is displayed as a slide -->

        <img src="assets/images/saucelabslogo.png" style="border:0; width:100px; height:100px; background:none; position:absolute; left:0; top:0;">
        <img id="lab_pic" src="assets/images/Laboratory2.png" style="visibility:hidden; border:0; width:200px; height:200px; background:none; position:absolute; right:0; top:0;">
        <img id="darksauce" src="assets/images/eggs/DarkSauce.png" style="visibility:hidden; border:0; width:500px; height:500px; background:none; position:absolute;">

        <div class="footer">
          <font size="1">© Copyright 2016 by ServiceRocket, Inc | Confidential | Prepared for Sauce Labs</font>
        </div>

	    <div class="slides">

              <section data-background="rgb(226, 35, 26)">
                <h1>Appium 101</h1>

                <p style="text-align:center">
	              <small><i>Testing at the speed of awesome</i></small>
                </p>

                <p style="text-align:center;">
                  <small>
                    <small>Using Reveal.js</small>
                  </small>
                </p>
              </section>

              <section>
					<h3>Trainer Intro</h3>
<!-- left column-->
                    <div style="float:left;width:50%;" class="centered">
                      <p>
                      <strong>Jacob Teal</strong>
                      <p>Technology Consultant</p>
                      <p>B.A. Computational Mathematics</p>
                      <p><a href="mailto:jacob.teal@servicerocket.com">jacob.teal@servicerocket.com</a></p>
					  </p>
                    </div>
<!-- right column-->
                    <div style="float:right;width:40%;padding-right:0px;">
                      <img src="assets/images/starfish.png" style="border:0;background:none; left:0; top:0;">
                    </div>
				</section>

              <section>
                <h3>Course Administration</h3>
                <ul>
                  <li>This session is ~3 hours long</li>
                  <ul><li>10 min. breaks every hour</li></ul>
                  <li>Slides, demonstrations and exercises</li>
                  <li>PDF copy of the materials is available</li>
                  <li>Ask questions at any time</li>
                  <ul><li>Use the chat window</li></ul>
                </ul>
              </section>

              <section>
                  <h3>The Training Environment</h3>

                  <div style="float:left;width:50%;" class="centered">
                    <ul>
                      <li>ReadyTech virtual machines</li>
                      <li>Eclipse</li>
                      <li>Maven</li>
                    </ul>
                  </div>
                  <div style="float:right;width:50%;padding-right:0px;">
                    <ul>
                      <li>Appium Server GUI</li>
                      <li>Android Virtual Device (AVD)</li>
                      <li>Android vs. iOS</li>
                    </ul>
                  </div>

                  <aside class="notes">
                    <p>Before we go into the different parts we need to include in a script, let's talk about our training environment.</p>
                    <p>First off, we'll be working in a VM provided by ReadyTech today. If you have any problems during the course of labs, I will be able to go into your instance and help you out. You can just notify me using the ReadyTech instance to tell me that you need help.</p>
                    <p>We're also going to be working in Eclipse today. In Eclipse, we have set up the scripts within a framework called TestNG, for Java, that allows us to run the scripts with all of the dependencies it needs very easily.</p>
                    <p>That within that framework, there is a library, or build tool, called Maven that we are using to grab our dependencies, bundle them together, and then run our script.</p>

                    <p>Throughout the course today, the way we will run our tests is by using the "Maven test" command, which should compile all of our resources and dependencies together, and run it for us.</p>
                    <p>For those of you who may not have used Eclipse before, when you type in a line that does not have the right syntax, it will generally underline the offending line or part of the line that you need to fix, in red. If you simply hover or select that part of the line, Ecplise will give you suggestions on how to fix the problem.</p>

                    <p>In addition to to those frameworks in libraries, we'll be using the Appium Server GUI to faciliate testing on our local readytech machine. We'll also be setting up an Android Emulator that we will install and test our application on.</p>

                    <p>One last thing before we continue, we won't be testing any iOS applications today. This is due to the limitations of the training environment. So just to be clear, we can test on iOS devices and test iPhone applicaitons with Sauce Labs. The problem lies with the "local" lab environment.</p>
                    <p>That's not to say I won't go over iOS at all though. I'll be showing iOS examples alongside Android examples throughout the course..</p>
                  </aside>
                </section>

              <section>
                <h3>Agenda</h3>

                <img src="assets/images/agenda.png" style="border:0;background:none; left:0; top:0;">

                <aside class="notes">
                  <li>Introduction to Sauce Labs and Appium</li>
                  <li>Appium Basics</li>
                  <li>Write Appium Test Scripts</li>
                  <li>Appium Testing with Sauce Labs</li>
                  <li>Introduction to Testing Frameworks</li>
                  <li>Automated Testing Best Practices</li>
                </aside>
              </section>

              <!-- Intro to SL Module-->
                <section data-background="rgb(226, 35, 26)">
                  <h2>Introduction to Sauce Labs and Appium</h2>
                </section>

                <section>
                  <h3>Module Objectives</h3>
                  <p>This module enables you to:</p>
                  <ul>
                    <li>Understand how Sauce Labs fits into the CI/CD Life Cycle</li>
                    <li>Understand what Appium is and how it is used with Sauce Labs</li>
                  </ul>
                  <aside class="notes"></aside>
                </section>

                <section>
				  <h3>What is Sauce Labs?</h3>
                  <p>Testing infrastructure in the cloud for web and mobile web applications.</p>
                  <ul>
                  <li>Web Automated Testing</li>
                  <li>Mobile Automated Testing</li>
                  </ul>

                  <aside class="notes">
                    <ul>
                      <li>Selenium: Desktop and Mobile Browser Testing</li>
                      <li>Appium: Native Mobile Application Testing</li>
                    </ul>
                    <p>What is  Sauce Labs? They describe themselves as providers and supporters of Web Automated and Mobile Automated testing.</p>
                    <p>They support two very large open source projects, namely Selenium and Appium. Selenium is used for Desktop and mobile browser testing, while appium is used for native and hybrid application testing.</p>
                    <p>Sauce Labs provides environments that run your Selenium or Appium tests on any browser and OS combination you like - and they have over 500 combinations thereof. (if you include the different browser versions)</p>
                  </aside>
                </section>

                <section>
					<h3>Sauce Labs History</h3>
					<p>Founded in 2008, by Steven Hazel, John Dunham, and Jason Huggins (Co-creator of Selenium).</p>
                    <p>
                        <pre><span class="inner-pre" style="font-size: 30px">
  "Our purpose is to revolutionize testing
         so that development teams
     are free to innovate and deliver
        amazing applications—faster."</span></pre>
                    </p>

                    <aside class="notes">
                         Sauce Labs was founded in 2008 by Jason Huggins, co-creator of Selenium (the open source standard for automated testing frameworks) and Steve Hazel, current CTO. They set out to create a cloud-based platform for automated testing to free development teams from the hassle and cost of testing so they can focus on innovating their core capabilities.
                      </p>
                      <p>In an interview, Jason said the inspiration for starting Sauce labs came when he was working as a QA consultant. He was using Selenium to do browser testing, and the process of testing the apps in different browsers was taking too long. The problem was that all the testing was being done on one machine, so he split the tests onto 4 different machines, effectively running the tests in parallel, which cut the time drastically. Which is precisely what Sauce Labs does today.</p>
                  </aside>
                </section>

                <section>
					<h3>CI/CD Cycle</h3>

                    <img src="assets/images/sauceCI2.png" style="border:0; text-align:center; background:none;">
                    <p style="text-align:center;">Continuous Integration/Continuous Development</p>
                    <aside class="notes">
                      <p>Sauce Labs' value as a time saver is apparent even in its role in Continuous Integration and Delivery. </p>
                      <p>Traditionally, testing and QA are bottlenecks for application delivery and release. Writing automated tests, maintaining testing infrastructure, painful manual testing, all consume huge amounts of time. The work is never done either, because the product is always changing.</p>
                      <p>Sauce Labs takes away those worries though. With Selenium and Appium testing, we remove the barrier of time consuming test writing, and with Sauce Labs itself, we remove the need to have a propietary infrastructure. Sauce Labs provides the infrastructure for you, allowing you to test on a variety of platforms in a speedy manner. So you can focus on development, and releases,and leave the testing to Sauce Labs.</p>
                      <p>Sauce Labs reduces the pain of testing, so that instead of traditionally waiting until the end of the development life cycle to test, you can test iteratively, as you go through each step of development.</p>
                    </aside>
                </section>

                <section>
				  <h3>What is Appium?</h3>
                  <p>Open source mobile application automation framework developed in 2011 by Dan Cuellar, the Test Manager at Zoosk.</p>
				  <p>Uses UIAutomation Framework to run in real time like an interpreter.</p>
                  <ul>
                    <li>Simulate mobile gestures</li>
                    <li>Automate Mobile Application Testing</li>
                  </ul>

                  <aside class="notes">
                    <p>Appium was developed in 2011 when Dan Cuellar wasn't satisfied with the current landscape of mobile testing tools. Dan came up with the idea of running Apple's UIAutomation framework as a real time interperter and used Apple utilities to execute shell commands, ordered text files to recieve commands, evalutate the output, execute said commands, and write them to disc using Python.</p>
                    <p>Then he created a C# version of the program, which mimicked Selenium-style syntax to sequentially order javascript commands and the first iteration of Appium was born.</p>
                    <p>Dan then presented his project at the Selenium Conference in 2012 and caught the attention of Jason Huggins. Jason and Dan worked together to release the source code and then present the project at the Mobile Testing Summit of 2013. Not long after, Sauce Lab fully backed Dan's project, changed the name to Appium and the rest is history.</p>

                  </aside>
				</section>

                <section>
				  <h3>Local vs. Sauce Labs Appium Tests</h3>

                  <div style="float:left;width:50%;" class="centered">
                    <p>Local:</p>
                      <ul>
                        <li>Requires Appium Server running locally or remotely</li>
                        <li>iOS development requires Xcode tools</li>
                        <li>Need all the libraries and images to run device simulators/emulators</li>
                    </ul>
                  </div>
                  <div style="float:right;width:50%;padding-right:0px;">
                    <p>Sauce Labs:</p>
                    <ul>
                      <li>Appium server is remote and provisioned for you</li>
                      <li>Device images and virtualization</li>
                      <li>Parallelization</li>
                      <li>Record Results</li>
                    </ul>
                  </div>

                  <aside class="notes">
                    <p>In general, no Appium test is going to be strictly "local". Running any kind of Appium test requires the use of the Appium Server, that acts as a middleman between the test commands and the emulator or simulator.</p>
                    <p>You can test android on any OS, (windows, Mac OSX, linux). But testing iOS applications requires a Mac OSX operating system. This is because the simulator for the iOS operating system requires some libraries and frameworks that only come with XCode, which can only be used on Mac OSX.</p>
                    <p>Android itself requires the SDK, and a lot of other helpful libraries and frameworks as well. But in order to test on a local machine, rather than in the cloud on Sauce labs or otherwise, you need to have the emulator/simulator program, and in the case of Android, you need to have the right OS version and phone libraries in order to run the emulator. The android SDK generally makes this pretty easy to get and apply, but it does take up a lot room on a machine. When you combine this with testing on many different OS versions and types or devices, then it can be a lot to manage.</p>
                    <p>Sauce Labs handles all of that device management for you. They run an Appium Server themselves, provide multiple mobile OS, version, and type combinations, and rent it out to their customers to run their Appium tests on. </p>
                  </aside>
				</section>

                <section>
                  <h3>Using Sauce Labs</h3>
                  <div style="float:right;width:50%;padding-right:25%;"><img src="assets/images/UsingSauceLabs.png" style="border:0; text-align:center; background:none;">
                  </div>

                  <aside class="notes">
                    <p>If hosting Mobile Application testing infrastructure itself isn't enough, Sauce Labs provides a whole slew of other additional features, such as security, recorded tests and integration with other tools. Sauce Labs provides security through it's Sauce Connect technology, which allows you to run tests on your locally hosted application. It sends your Selenium or appium commands through an encrypted tunnel, ensuring that your information is protected.</p>
                    <p>Seamless integration refers the multitude of platforms that Sauce integrates with, such as Jenkins, Bamboo, JIRA, and more.</p>
                    <p>And each test you run is recorded by default. This includes screenshots, a video recording of the entire test, as well as log files.</p>
                  </aside>
                </section>

                <section>
                  <h3>Sauce Labs UI</h3>
                  <img src="assets/images/SL_dash.png" style="float:center;border:none; background:none; width:100%">
                  <aside class="notes">
                    <p>Let's go ahead and take a look at Sauce Labs right now.</p>
                    <li>Dashboard: On the dashboard, there are 3 different tabs. These help organize the kinds of tests that we run on Sauce Labs.</li>
                    <p>We have a tab for tests that are run and labelled as builds, one for our automated tests, and one for manual tests.</p>
                    <li>Tunnels: The tunnels tab will list out all of secure tunnels that are currently enabled and running between Sauce Labs and your local machine.</li>
                    <li>Account Details: Lastly, our account details page is important. You can see your VM usage, as well as find your access key, which is required for authentication when using Sauce Labs. We'll go into how to use it later on.</li>

                  </aside>
                </section>

                <section>
                  <h3>Manual Testing</h3>
                  <p>The traditional method of testing applications and sites.</p>
                  <ul>
                    <li>Testing Locally</li>
                    <li>Sauce Labs Manual Tests</li>
                  </ul>
                  <aside class="notes">
                    <p>Do the demo on Android!!! It will go faster than iOS.</p>

                    <p>Traditionally, once your mobile browser application was ready to be tested, you would load it onto a physical device, and then test it with your own fingers. There are a few problems with that, namely, it takes a lot of time to do and you're limited to the devices you have. So then you can run your test manually on an emulator or simulator to take care of the device problem. But the issue of time, of someone physically clicking on the device emulator or phyiscally touching the device is a huge time suck.</p>
                    <p>With Sauce Labs, you can run manual tests without having to set up the infrastructure locally. This can help you with memory issues you may run into running simulators and emulators on your own local machine, and can give you a good way test out a mobile browser application on more devices than you could easily do locally.</p>
                    <p>One thing to note about manual testing with Sauce Labs - you can't start a manual test with an application preloaded. There are a couple ways to get around this though. If you start a normal automated test, you can interrupt it, and take control of the app. And if you use Sauce Connect Proxy, then you can interact with a local emulator you may be running, that can have your app installed on it.</p>
                    <p>Manual Test Demo: </p>
                    <ol>
                      <li>Go to saucelabs.com</li>
                      <li>Click on manual tests tab</li>
                      <li>click on new manual test in the top left.</li>
                      <li>click on android bot</li>
                      <li>select android emulator for the device</li>
                      <li>point out sauce connect - then start the session.</li>
                    </ol>
                    <p>Questions?</p>
                  </aside>
                </section>

                <!--Appium Test Scripts Basics Module-->
                <section data-background="rgb(226, 35, 26)">
                  <h2>Appium Basics</h2>
                  <aside class="notes"></aside>
                </section>

                <section>
                  <h3>Module Objectives</h3>
                  <p>This module enables you to:</p>
                  <ul>
                    <li>Understand how Appium works</li>
                    <li>Understand the basic components of Appium test scripts</li>
                    <li>Run an Appium test script on a local emulator</li>
                  </ul>
                  <aside class="notes"></aside>
                </section>

                <section>
                  <h3>4 Pillars of Appium Philosophy</h3>
                  <p>Appium was designed to meet mobile automation needs according to a philosophy outlined by the following four tenets:</p>
                  <ol>
                    <li>You shouldn't have to recompile or modify your app to automate it</li>
                    <li>You shouldn't be restricted to a specific language or framework to write and run your tests</li>
                    <li>Appium shouldn't reinvent the wheel when it comes to automation APIs</li>
                    <li>Appium should be open source</li>
                  </ol>
                  <aside class="notes">
                    <p>Paraphrase the tenets.</p>
                    <p>Appium is a bundle of all of the specific language bindings that allow a client to send information to automation libraries that have been developed by Google and Apple. The appium library converts language specific commands to the commands that those automation libraries understand, which then performs actions on mobile devices.</p>
                   <p>Since Selenium was already created, and had a client webdriver and api, appium didn't want to reinvent the wheel and create what would essentially be the same thing. So that's why Appium is built on top of Selenium, and uses many of the same driver functionalities. </p>
                  </aside>
                </section>

                <section>
				  <h3>Appium Nuts and Bolts</h3>
                 <div style="text-align:center;">
                    <img src="assets/images/AppiumGears.png" style="border:0; background:none; width:50%">
                 </div>
                 <ul>
                   <li>Appium Client Libraries (extends Selenium Webdriver)</li>
                   <li>Appium Server</li>
                   <li>Appium GUI</li>
                  </ul>
                 <aside class="notes">
                   <p>Appium has a client/server architecture. In order to send commands to the local or remote appium server which will pass those along to a device, we need the Appium client.</p>
                   <p>The appium client is simply a library that you can use to write Appium test scripts in your favorite language. These client libraries are extensions of the Selenium WebDriver client, so they should have all the same functionalities, as well as syntax.</p>
                   <p>The Appium server is a Node.js webserver, that has an exposed REST API. It connects with the client, accepts commands, executes those commands on a mobile device, and then passes the results of those commands back in an HTTP response. The client/server architecture gives us a lot of freedom. It allows us to run the the server on a different machines than where we run our tests. This also allows Sauce Labs to run tests for you on their cloud service.</p>
                   <p>The Appium GUI is wrapped around an appium server, which means we don't have to worry about having Node installed on our system. It will come bundled with everything it needs to start up the server itself.</p>
                   <p>But most importantly, the Appium GUI comes with the Inspector, which allows you to look through the element hierarchy of your app. This can help when you are writing your tests, so you know exactly what sequence of actions, on the correct elements, to perform on the app.</p>
                   <p>Today, we'll be using the GUI to run a local appium server, but the inspector on the GUI doesn't work very well on Windoes. I'll show you how useful it is in a later module.</p>
                    <ul>
                      <li>Appium Server</li>
                      <li>WebDriver JSON wire protocol</li>
                      <li>UIAutomation or UIAutomator framework</li>
                      <li>Mobile Simulator/Emulator</li>
                      <li>Appium Server Response Data<li>
                      </ul>
                  </aside>
				</section>

                <section>
                  <h3>UI Automator (Android)</h3>

                </section>

                <section>
                  <h3>UI Automation (iOS)</h3>

                </section>

                <section>
                  <h3>Testing on Windows Operating Systems</h3>

                  <p>Requirements:</p>
                  <div style="float:left;width:50%;" class="centered">

                    <ul>
                      <li>Node.js</li>
                      <li>Appium.exe</li>
                      <li>Android SDK &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (>= API Level 17)</li>
                      <p hidden>)</p> <!--Some silly formatting-->
                    </ul>
                  </div>
                  <div style="float:right;width:50%;padding-right:0px;">
                  <ul>
                    <li>Java</li>
                    <li>Apache Ant</li>
                    <li>Apache Maven</li>
                  </ul>
                  </div>
                  <div style="float:left;width:100%;">
                    <p style="text-align:center;">
                      <small>Documentation: <a href="http://appium.io/slate/en/master/?java#setup" target="_blank">Running Appium on Windows</a></small>
                    </p>
                  </div>
                  <aside class="notes">
                    <p>On a windows operating system, you're only going to be able to test android applications. iOS mobile development requires some technology that only runs on mac. However, this won't prevent you running tests on iOS, remotely at least. Finding out what you're actually trying to test can be tricky if you can't see what youre look at though!</p>
                    <p>So we need a lot of technology here! We should be able to find all of these programs, frameworks and libraries on our environment, either as its own program, or bundled in with Eclipse.</p>
                    <p>You should also install git if you are planning on having version control for your script code. Another program you can install is cURL, if you are planning on using Sauce storage to host your application to test on sauce labs.</p>
                    <p>If you'd like to see the exact set-up steps, you can look in the documentation. This whole set-up should be done already for you in today's lab environment.</p>
                  </aside>
                </section>

                <section>
                  <h3>Testing on Mac OS X Operating Systems</h3>
                  <p>Requirements:</p>
                  <ul>
                    <li>Requires Mac OS X</li>
                    <li>Xcode >= 7.1 recommended</li>
                    <li>iOS SDK(s)</li>
                    <li>Authorize iOS</li>
                 </ul>
                 <p style="text-align:center;">
                   <small>Documentation: <a href="http://appium.io/slate/en/master/?java#running-appium-on-mac-os-x" target="_blank">Running Appium on Mac OS X</a></small>
                 </p>
                 <aside class="notes">
                   <p>If you use a Mac OS regularly, then you can do android and iOS testing locally. The android set will be pretty much the same, just with some tweaks to fit in with standard mac program installations.</p>
                   <p>But testing you iOS app on mac requires the XCode tools, the iOS SDKs, and you need to authorize you computer to run the iOS simulator.</p>
                    <p>Recommend Mac OS X 10.10</p>
                    <p>Authorize: You need to authorize use of the iOS Simulator by running the authorize-ios binary made available through npm. If you installed globally, by running npm install -g appium, use
                      <pre style="display:inline;">sudo authorize-ios</pre>
                      If you installed locally, the binary will be installed within the node_modules/.bin directory, so use <pre style="display:inline;">sudo node_modules/.bin/authorize-ios</pre>
                      # alternatively
                      <pre style="display:inline;">sudo $(npm bin)/authorize-ios</pre>
                      If you are running Appium.app, you can authorize iOS through the GUI. You need to do this every time you install a new version of Xcode.</p>
                  </aside>
                </section>

                <section>
                  <h3>Types of Mobile Apps to Test</h3>
                  <ul>
                    <li>Mobile Web Browser Application</li>
                    <li>Native Application</li>
                    <li>Hybrid Application</li>
                  </ul>

                  <aside class="notes">
                    <p>With regards to mobile applications, there are three different types that require different kinds of test setups.</p>
                    <p>Mobile Web browser - these types of tests simply pull up your application on a mobile browser, like mobile chrome, FF, safari.</p>
                    <p>Native app - native app testing goes into the application itself, and works with the native or inherent application elements, rather than using a browser or webview to access your application site.</p>
                    <p>Hybrid app - Native app that has a bar on the top, bottom, and then pulls up/uses a webview. </p>
                    <p>All three of these require various settings in your test, with regards to Desired Capabilities. We'll examine those later on.</p>
                  </aside>
                </section>

                <section>
                  <h3>Appium GUI</h3>
                  <div style="text-align:center">
                    <img src="assets/images/app_inspector.png" style="border:0; background:none; width:100%">
                  </div>
                  <aside class="notes">
                    <p>As was mentioned a little earlier, the Appium GUI is a wrapper around the aapium node.js server. It bundles up all of the assets that you need for the appium webserver, as well as provides you with an inspector. The inspector is the core part of the GUI, as it enables you to examine the elements and hierarchy of elements in your application, which helps when writing Appium test scripts.</p>
                  </aside>
                </section>

                <section>
				  <h3>How Appium Works</h3>
                  <p>
                    <ol>
                      <li>Write script</li>
                      <li>Run script - Sends commands to Appium Server via Appium Client library</li>
                      <li>Appium Server sends commands to mobile simulator/emulator</li>
                      <li>Appium Server sends results back</li>
                      <li>(On Sauce Labs) Test Assets are created</li>
                    </ol>
                  </p>
                  <aside class="notes">
                    <p>So we went over how appium works on high level, but let's get down to some specifics.</p>
                    <p>First, we need to actually write our test script. When we go to run it, the Appium Client library that we used to will connect and send the commands to the local or remote appium server. Our script and the commands we write in it all talk to the REST API on the Appium server, via HTTP requests.</p>
                    <p>The appium server then sends those commands to the device, and then collects and sends the results back via and HTTP response.</p>
                    <p>Our script then takes those results, and it's up to us to pass those results onto Sauce Labs, or deal with them locally.</p>
                    <p>If we run this test using Sauce Labs, then one more additional step will be done, which is to create the test records, so the video recording, screenshots, and logs.</p>
                  </aside>
				</section>

                <section>
                  <section>
				    <h3>Basic Steps of an Appium Script</h3>
				    <div style="position:left;float:left;">
                      <img src="assets/images/7Steps.png" style="border:none; background:none; width:50%">
                    </div>
                    <div style="text-align:left;float:left;width:80%;">
                      <p>
                        <ol>
                          <li>Set the Desired Capabilities (or Set the Application Path)</li>
                          <li>Start an Appium Session</li>
                          <li>Locate an Element in the Application</li>
                          <li>Perform an Action on an Application Element</li>
                          <li>Anticipate Application Response</li>
                          <li>Validate Responses and Reporting Test Results</li>
                          <li>Conclude a Test</li>
                        </ol>
                      </p>
                    </div>

                    <aside class="notes">
                      Step through example script - point out each step that correlates to an element.
                    </aside>
				  </section>

                  <section>
				    <h3>1. Set the Desired Capabilities</h3>

                    <p>Web Browser</p>
                    <pre><code class="java" data-trim contenteditable>
                    capabilities.setCapability("platformName", "Android");
capabilities.setCapability("platformVersion", "4.4");
capabilities.setCapability("deviceName", "Android Emulator");
capabilities.setCapability("browserName", "Chrome");
                    </code></pre>
                    <p>Native/Hybrid</p>
                      <pre><code class="java" data-trim contenteditable>
                          capabilities.setCapability("platformName", "Android");
capabilities.setCapability("platformVersion", "4.4");
capabilities.setCapability("deviceName", "Android Emulator");
capabilities.setCapability("app", "https://github.com/appium/app.apk");
                      </code></pre>

                    <aside class="notes">
                      <p>For those of you who may have done local Selenium testing, some of these Desired Capabilities may look unfamiliar. One key difference between selenium and Appium is that Appium requires an Appium webserver, even for local tests. We need to set these desired capabilties so the client can tell the server what settings we want to test with.</p>
                      <p>In our case, we are going to be testing on the Android Emulator, and we're going to load up our app, from github onto that device and run our test on it.</p>
                      <p>There are quite a few desired capabilities we can set, and we'll take a look at some of them more in depth later. A key capapbility I want to point out here though is the "app" capability. You'll notice it goes to github.com to grab the app. We can set this to many different locations, and when doing local tests, it can point to somewhere in your filesystem as well. Sauce Labs also has their own application storage solution that can be used when running appium tests.</p>
                    </aside>
				  </section>

                  <section>
                    <h3>2. Start an Appium Session</h3>
                    <p>Android</p>
                      <pre><code class="java" data-trim contenteditable>
                          AndroidDriver&#60;MobileElement&#62; driver = new AndroidDriver&#60;MobileElement&#62;(
    new URL("http://localhost:4723/wd/hub"),
    capabilities);
                      </code></pre>
                      <p>iOS</p>
                      <pre><code class="java" data-trim contenteditable>
                          IOSDriver&#60;MobileElement&#62; driver = new IOSDriver&#60;MobileElement&#62;(
    new URL("http://localhost:4723/wd/hub"),
    capabilities);
                      </code></pre>
                    <aside class="notes">

                      <p>These two drivers both inherit from the general Appium driver class, and add in functions that are useful for testing in the context of their operating systems, such as the UIAutomation and UIAutomator classes, for iOS and Android, respectively.</p>
                      <p>These two examples we have here are both for starting tests with a local Appium Server and emulator/simulator.</p>
                      <p>Note that the URL goes to localhost:4723, which is the default address for a local appium server. The driver object stores the URL to pass along commands to, and also passes along the capabilities the test needs.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>Different Drivers</h3>
                    <div style="float:left;width:50%;" class="centered">
                      <ul>
                        <li>RemoteWebDriver</li>
                        <li>AppiumDriver</li>
                      </ul>
                    </div>
                    <div style="float:right;width:50%;padding-right:0px;">
                      <ul>
                        <li>AndroidDriver</li>
                        <li>IOSDriver</li>
                      </ul>
                    </div>
                    <aside class="notes">
                      <p>These are the different kinds of drivers that are generally available, when testing with Appium or even Selenium. It's important to know the differences between them.</p>
                      <p>RemoteWebDriver: This driver class comes directly from Selenium. Since Appium operates on the client-server model, Appium uses this to initialize a driver session. However, since we are doing mobile testing, using the RemoteWebDriver is not recommended since there are other drivers available that offer additional features or convenience functions.</p>

                      <p>AppiumDriver: This driver class inherits from the RemoteWebDriver class, but it adds in additional functions that are useful in the context of a mobile automation test through the Appium server.</p>

                      <p>AndroidDriver: This driver class inherits from AppiumDriver, but it adds in additional functions that are useful in the context of a mobile automation test on Android devices through Appium. Only use this driver class if you want to start a test on an Android device or Android emulator.</p>

                      <p>IOSDriver: This driver class inherits from AppiumDriver, but it adds in additional functions that are useful in the context of a mobile automation test on iOS devices through Appium. Only use this driver class if you want to start a test on an iOS device or iOS emulator.</p>
                      <p>All over these Appium or mobile drivers build on the original Selenium RemoteWebDriver, and then add in their own additional functionalities.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>3. Locate an Element in the Application</h3>

                    <div style="float:left;width:70%;" class="centered">
                    <pre syle="width:100%;">
                      <code class="java" data-trim contenteditable>
                        &#60;android.widget.TextView
content-desc="Text"
class="android.widget.TextView" text="Text"
index="9" enabled="true" checkable="false"
checked="false" clickable="true" focusable="false"
location="[0, 702]" size="[800, 64]"
package="io.appium.android.apis"
password="false" resource-id="android:id/text1"
scrollable="false" selected="false"
xpath="//android.view.ViewGroup[1]/
android.widget.FrameLayout[2]/
android.widget.ListView[1]/
android.widget.TextView[10]"/&#62;
                      </code>
                    </pre>
                    </div>
                    <div style="float:right;width:30%;padding-right:0px;">
                      <div style="text-align:center;">
                        <img src="assets/images/app_elems.png" style="border:0; background:none;">
                      </div>
                    </div>

                    <aside class="notes">
                      <p>You can see how the XML correlates with each line in the GUI element viewer.</p>
                      <p>In the Appium GUI, you can serach through the elements in a convenient interface (as seen on the left), at each point of your applciation element infrastructure. If you aren't planning on using the Appium GUI, you can use a command, similar to println debugging to get the structure of elements in your app. And that is the driver.getPageSource() directive.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>Identify an Element</h3>
                    <pre style="width:94%;">
                        <code class="java" data-trim contenteditable>
                          textBox = driver.findElement(By.id("com.saucelabs.guineapig:id/fbemail"));
                        </code>
                    </pre>
                    <p>Identifiers:</p>
                    <div style="float:left;width:50%;" class="centered">
                      <li>ID</li>
                        <li>Class Name</li>
                        <li><s>Tag Name</s></li>
                    </div>
                    <div style="float:right;width:50%;padding-right:0px;">
                      <li><s>Link Text</s></li>
                        <li><s>Partial Linktext</s></li>
                        <li><s>CSS</s></li>
                        <li>XPath</li>
                    </div>
                    <aside class="notes">
                      <p>All of the identifiers listed here are from selenium. When testing mobile browser or hybrid applications, they can still be used.</p>
                      <p>But for native application testing, the crossed out identifiers can't be used.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>OS Specific Identifiers</h3>

                    <div style="float:left;width:50%;" class="centered">
                      <p>Android: </p>
                      <ul>
                        <li>UI Automator element class name</li>
                        <li>-android uiautomator</li>
                        <li>Accessibility id</li>
                        <ul><li>content-description</li></ul>
                      </ul>
                    </div>

                    <div style="float:right;width:50%;padding-right:0px;">
                      <p>iOS:</p>
                      <ul>
                        <li>UI Automation element class name</li>
                        <li>-ios uiautomation</li>
                        <li>Accessibility identifier</li>
                      </ul
                    </div>

                    <aside class="notes">
                      <p>Instead, we can use the OS specific Identifiers.</p>
                      <p>The automation classes provide a way to collect or search for particular elements through the UI class.</p>
                      <p>Appium exposes two methods of using the underlying device automation technology directly, in order to find elements. This is especially useful when a test needs some fine-grained control over finding elements. These are the android automator and ios automation frameworks.</p>
                      <p>For iOS mobile testing that uses the ios automation framework, the Appium server converts the WebDriver commands from your test script into the UIAutomation JavaScript commands that can be understood by Apple Instruments. These commands are then sent to your iOS mobile application and execute those commands against the application in the simulator or device.</p>
                    <p>For Android Appium tests that use the android automator framework, require the Appium Server to convert the test script commands into UIAutomator Java commands, parse the data when testing it against your mobile emulator of your choice, then convert the response back, and relay the data to the appium script</p>
                      <p>content-description: <pre style="display:inline;">android:contentDescription=”@string/pause”/></pre></p>
                      <p>For both platforms getting an element, or multiple elements, by their accessibility id is usually the best method.</p>
                      <p>We'll go over these in more detail in the next module.</p>
                    </aside>
                  </section>

                  <section>
				    <h3>4. Perform an Action on an Application Element</h3>

                    <pre>
                      <code class="java" data-trim contenteditable>
                        newGameBtn = driver.findElement(By.
    id("com.google.android.divideandconquer:id/newGameBtn"));
touch.tap(newGameBtn).perform();
                      </code>
                    </pre>
                    <aside class="notes">
                      <p>In our example, we frist locate the element, in this case by ID, and then perform a tap on that element. If you don't give the tap command a set of coordinates, it will tap the center of the element by default.</p>
                      <p>Those of you who have used selenium may be familiar with using a simple .click() on the end of an element. click() and tap() are pretty  much the same. In fact, when using the appium client library, the click() uses the underlying touch software to perform what is equivalent to a tap() touch.</p>
                      <p>We'll go over actions in more depth in the next module.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>5. Anticipate Application Response</h3>
                    <p>Implicit Waits</p>
                    <ul>
                      <li>A blanket wait time that applies to each findElement search (findElement(By.id())).</li>
                    </ul>
                    <p>Explicit Waits</p>
                    <ul><li>A wait time set until a condition of an element (such as "selected" or "visible") becomes true.</li>
                    </ul>
                    <aside class="notes">
                      <p>Tests might fail because the elements that are expected for the next step haven't loaded in the app yet. It's good to have an explicit wait time in this case as it can be variable how long it takes for an element to be loaded, especially if an action takes us to a new screen or view in the app.</p>
                       <p>While we may not have waits in our current script, we will take a look at them in a later module.</p>
                      <p>DEMO: now toggle a breakpoint at this line in the script, and step through.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>6. Validate Responses and Reporting Test Results</h3>

                     <div style="float:left;width:50%;" class="centered">
                       <ul>
                         <li>Print or save your test results locally, as part of your script</li>
                         <li>Test Frameworks</li>
                         <li>Use the Sauce Labs API to send results to your Dashboard</li>
                         <ul>
                     </div>
                     <div style="float:right;width:50%;padding-right:0px;">
                       <ul style="list-style-position: outside; margin-left= 1em">
                         <li>Test results automatically recorded with Sauce Labs</li>
                         <ul>
                           <li>Logs</li>
                           <li>Screencasts</li>
                           <li>Screenshots</li>

                         </ul>
                       </ul>
                     </div>
                     <aside class="notes">
                       <p>When running tests with Sauce Labs and locally, recording test results need extra configuration. By default, you will be able to see when a test is complete, or has "errored out". But without specific test results sent back to Sauce Labs or custom made locally, you have no way of knowing whether a complete means a test was successful, or whether a failure means the test failed or if the test wasn't written correctly.</p>
                         <p>Test frameworks can help us report our results more definitively, back to Sauce Labs and locally. Through the Sauce Labs UI, we get some core reporting/recording of test results through their screenshots, screencast of the test, and logs.</p>
                       <p>DEMO: now toggle a breakpoint at this line in the script, and step through.</p>
                     </aside>
                  </section>

                  <section>
				    <h3>7. Conclude a Test</h3>
                    <pre>
                      <code class="java" data-trim contenteditable>
                        driver.quit();
                      </code>
                    </pre>
                    <aside class="notes">
                      <p>Lastly, We need to use driver.quit() in order to end the test. It should close all browser windows and end the webdriver session. If we don't use it, we can get several different errors, such as incorrect results (incomplete test), timeout errors, the webdriver session will not be closed properly and files will not be cleared off memory, which can increase the space used on your computer's hard drive.</p>

                      <p>DEMO: now toggle a breakpoint at this line in the script, and step through.</p>
                    </aside>
                  </section>
                </section>

                <section>
                  <section data-state="lab">
                    <h3>Lab 1: Set-up</h3>
                    <ol>
                      <li>Double-click on the Android_virtual_device.bat file on the desktop to start the AVD.</li>
                      <li>Double-click on the Appium desktop icon.</li>
                      <li>After the device has loaded, press the play button on the Appium GUI.</li>
                      <li>Open Eclipse from the desktop shortcut.</li>
                    </ol>
                  </section>

                  <section data-state="lab">
                    <h3>Lab 1: Running the Sample Appium Script</h3>

                    <ol>
                      <li>In the Eclipse package explorer left hand side panel, local-java-testng-appium-android > src/test/java > com.yourcompany > Local_SampleSauceTest.java.</li>
                      <li>Note the identified WebElement, and the we are enacting upon it..</li>
                      <li>Right click on java-testng-simple and select Run As > 9 Maven test.</li>
                      <li>Click on the device and Appium icons on the toolbar.</li>
                      <li>What did you see happen? How did it happen?</li>
                    </ol>
                  </section>
                </section>

<!--Writing Appium Scripts Module-->
                <section data-background="rgb(226, 35, 26)">
                  <h2>Write an Appium Test Script</h2>
                </section>

                <section>
                  <h3>Module Objectives</h3>
                  <p>This module enables you to:</p>
                  <ul>
                    <li>Identify elements in your application structure</li>
                    <li>Write actions into your Appium test script</li>
                    <li>Run a local Appium Android test</li>
                  </ul>
                </section>

                <section>
                  <section>
                    <h3>Identifying Elements</h3>
                    <p style="text-align:center;">Locator Expressions are made in Key:Value pairs</p>
                    <pre><code class="java" data-trim contenteditable>
                        WebElement newGameBtn = driver.findElement(
    By.id("com.google.android.divideandconquer:id/newGame"));
                    </code></pre>
                    <aside class="notes">
                      <p>We took a look at locating elements briefly in the pervious module, and now we have some examples on using each of the different locator types.</p>
                      <p>Generally, our locator expressions are made in Key:Value pairs. In our example here, the key would be the id, specifically, the resource id, which is then followed by the resource id value in parentheses.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>Android Locators</h3>
                    <p>UI Automator class name</p>
                    <pre><code class="java" data-trim contenteditable>
                        textView = driver.findElementByClassName("android.widget.TextView");
                    </code></pre>
                    <p>Acessibility id</p>
                    <pre><code class="java" data-trim contenteditable>
                        newGameBtn = driver.findElementByAccessibilityId("New Game");
                    </code></pre>
                    <aside class="notes">
                      <p>Android has an automation framework called UI Automator. We can identify elements by their UI Automator framework class names.</p>
                      <p>In the mobile environment, ids are not, as in WebDriver, CSS ids, but rather a kind of native identifier. For Android, the accessbility id is one of the easiest ways to identify an element. findElementByAccessibilityId() maps to the "content-desc" value of an android element.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>Android Locators cont.</h3>

                    <p>-android uiautomator</p>
                    <ul>
                      <li>UIAutomator language</li>
                    </ul>
                    <pre><code class="java" data-trim contenteditable>
                        UiDevice device = UiDevice.getInstance(getInstrumentation());
UiObject cancelButton = device
    .findObject(new UiSelector()
    .text("Cancel"))
    .className("android.widget.Button"));
                    </code></pre>
                    <ul>
                      <li>Appium script</li>
                    </ul>
                    <pre style="width:95%"><code class="java" data-trim contenteditable>
                        WebElement cancelButton = driver.findElementsByAndroidUIAutomator(
     "new UiSelector().text("Cancel").className("android.widget.Button")");
                    </code></pre>

                    <aside class="notes">
                      <p>The UIAutomator language is the Android specific automation framework, made by Google. The Appium java client library can take in a form of the native UIautomator syntax, and then uses that directly in the app to identify or interact with elements. The results then get converted and passed back to the appium script.</p>
                      <p>You can see in the top example we have an example of the native UIAutomator syntax. In the below example, we can see the appium script takes pieces of the original syntax in it's argument, which it will then use, in this case, to id a cancel button in our application.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>iOS Locators</h3>
                    <p>UI Automation class name</p>
                    <pre><code class="java" data-trim contenteditable>
                        MobileElement fieldTwo = (MobileElement) driver.
    findElementsByClassName("UIATextField").get(1);
                    </code></pre>
                    <p>Acessibility id</p>
                    <pre><code class="java" data-trim contenteditable>
                        MobileElement fieldOne = (MobileElement) driver.
    findElementByAccessibilityId("TextField1");
                    </code></pre>

                    <aside class="notes">
                      <p>Similar to android, one way we can find an element or set of elements in iOS is through the UIAutomation class name. In our example here, we are selecting the the elements with the class name UIATextField, and then selecting the second element in the resulting list. Hence, that is why fieldTwo is the name of our MobileElement variable.</p>
                        <p>For iOS the IDs are a little complicated. Appium will first search for an accessibility id that matches. If there is none found, a string match will be attempted on the element labels. Finally, if the id passed in is a localization key, it will search the localized string.</p>
                    </aside>
                  </section>

                <section>
                  <h3>iOS Locators cont.</h3>
                  <p>-ios uiautomation</p>
                  <li>UIAutomation JavaScript API script</li>
                  <pre><code class="java" data-trim contenteditable>
                      UIATarget.localTarget().frontMostApp().mainWindow()" +
    ".scrollViews()[0].cells()
    .firstWithPredicate(\"name matches 'Sign In'\");
                  </code></pre>

                  <li>Appium script (Java)</li>
                  <pre><code class="java" data-trim contenteditable>
                      String uiautoFind = "UIATarget.localTarget().frontMostApp().mainWindow()" +
    ".scrollViews()[0].cells()
    .firstWithPredicate(\"name matches 'Sign In'\")";
driver.findElementByIosUIAutomation(uiautoFind);
                  </code></pre>

                  <aside class="notes">
                    <p>DEMO: show how you can find elements using the Inpspector. It won't work on their windows instance (only stays up for 60secs). So we demo on our local comp. But show correlation between getPageSource() XML and the inspector.</p>
                    <p>Similar to the Android UI Automator framework iOS has one called UIautomation. And it's purpose is the same - to automate iOS apps. So appium takes in the native uiautomation syntax as a string and then takes that string as an arugment in driver.findElementbyiosuiautomation.</p>
                  </aside>
                </section>
                </section>

                <section>
                <section data-state="lab">
                  <h3>Lab 2: Getting the Page Source</h3>
                  <ol>
                    <li>Restart the Appium Server.</li>
                    <li>Bring Eclipse to the foreground.</li>
                    <li>In Local_SampleSauceTest.java, write in the following line of code in the line after the button tap.</li>
                    <pre style="width:58%;"><code class="java" data-trim contenteditable>
                        System.out.println(driver.getPageSource);
                    </code></pre>
                    <li>Run the test.</li>
                    <li>Note the XML that apears in the Eclipse console.</li>
                  </ol>
                  <aside class="notes">
                    <p>As part of this lab, manually go through the app and show where we are trying to navigate to: Touch Paint. When we take a look at the xml before any scrolling we can see that it is not in the view, and we will need to scroll down before we can find the element.</p>
                    <p></p>
                  </aside>
                </section>

                  <section data-state="lab">
                    <h3>Lab 2: Analyzing the Page Source</h3>
                    <ol>
                      <li>Go to your desktop and open the folder called "XML Inspector Examples".</li>
                      <li>Double-click on the file called "beforeScrollTo".</li>
                      <li>Note the formatted XML. Can you recognize elements in the XML that appear in the application?</li>
                    </ol>
                  </section>
                </section>

                <section>
                  <section style="padding-left:10px;">
                    <h3>Mobile Specific Actions (Gestures)</h3>
                    <ul>
                      <li>Once you locate an element, you can perform an action on it</li>
                      <p></p>
                      <li>Perform actions by invoking the driver, and then a gesture action that is performed on an element</li>
                    </ul>
                    <aside class="notes">
                      <p>So once we locate our elements, there are a couple of different ways we can go about performing actions on them. You can use a lot of the standard actions like click() and scrollTo() that come with the Selenium WebDriver libraries, but we're going to focus on how you can use some Touch, or mobile specific gestures.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>Touch Actions</h3>
                    <p>There is a TouchAction class in the appium client libraries, which contain the different actions you can perform on a mobile device.</p>
                    <pre><code class="java" data-trim contenteditable>
                        TouchAction touch = new TouchAction(driver);
                    </code></pre>

                    <aside class="notes">
                      <p>The main class that we will use today to implement touch gestures or actions on our elements is the Touch Action class.</p>
                      <p>A new TouchAction object requires the driver object to be passed into it. Let's take a look at some specific actions we can use.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>Gesture Actions</h3>
                    <p>press(x, y)</p>
                    <pre><code class="java" data-trim contenteditable>
                        //press(org.openqa.selenium.WebElement el, int x, int y)
touch.press(btnElem, 150, 100).perform();
                    </code></pre>

                    <p>moveTo(+x, +y)</p>
                    <pre><code class="java" data-trim contenteditable>
                        //moveTo(org.openqa.selenium.WebElement el, int x, int y)
touch.press(10, 200).moveTo( 1, 1).perform();
                    </code></pre>

                    <p>tap(element)</p>
                    <pre><code class="java" data-trim contenteditable>
                        //tap(org.openqa.selenium.WebElement el, int x, int y)
touch.tap(btnElem).perform();
                    </code></pre>

                    <aside class="notes">
                      <p>So first, we have a press(), which places a "finger" on the screen. In this particular case, we are giving it specific coordinates to press. But we could also pass it a webelement. Typically, we see these followed by a release(), which will withdraw the touch. I've inclduded the formal definition here, and it's important to note that you can use the element, and coordinates, or just coordinates or just an element. They can be used seperately. This will be true of the actions below this one as well.</p>
                      <p>The moveTo() works differently depending on what arguments it has. If it has just coordinates, then it will move the touch to a new position relative to the current position. So if we moved starting from (10,200), and did a moveTo(1,1), we would end up where?</p>
                      <p>Let them answer.</p>
                      <p>Good! If moveTois just given an element, it will move the current touch to the center of the given element. And lastly if it has an element and coordinates, then it will move to that element, but the coordinate reference is set from the top left corner.</p>
                      <p>Another action we have is tap, which is pretty straightforward. It's essentially a combination of a press() and a release(), just a quick tap on your screen.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>Other Gesture Actions</h3>
                    <p>waitAction(int ms)</p>
                    <pre><code class="java" data-trim contenteditable>
                        //waitAction(int ms)
action1.press(el1).waitAction(300).moveTo(10, 0).release().perform();
                    </code></pre>

                    <p>longPress(x, y, duration)</p>
                    <pre style="width:93%;"><code class="java" data-trim contenteditable>
                        //longPress(org.openqa.selenium.WebElement el, int x, int y, int duration)
action.longPress(ele1).moveTo(x1,580).release().perform();
                    </code></pre>

                    <p>perform()</p>
                    <pre><code class="java" data-trim contenteditable>
                        action.longPress(ele1).moveTo(x1,580).release().perform();
                    </code></pre>

                    <aside class="notes">
                      <p>Appium performs the touchaction events in sequence. It's also referred to as "chaining". You can add a wait event to control the timing of the gesture.</p>
                      <p>The longPress works similarly to the other actions we've already seen, but unlike the regular press(), we can include a time argument. </p>
                      <p>And lastly, we have the perform() function. This is what starts the long chain that is defined in front of it. Which is why all of my actions have performs on the end of them!</p>
                      <p>It's generally best practice to create a new touch object for each touch sequence you make. So for every perform() you have, it should be done on a unique touchAction object.</p>
                      <p>There are few more additional ones that you can use, but these are some the more important ones you should keep in mind when starting to write your appium tests.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>MultiTouch</h3>
                    <pre><code class="java" data-trim contenteditable>
                        MultiTouchAction multiAction = new MultiTouchAction(driver);
    TouchAction finger1 = new TouchAction(driver);
    TouchAction finger2 = new TouchAction(driver;

    finger1.longPress(x1,y1).waitAction(1500);
    finger2.longPress(x2,y2).waitAction(1500);
    multiAction.add(finger1).add(finger2).perform();
                    </code></pre>
                    <aside class="notes">
                      <p>And lastly for actions, we have Multitouches.</p>
                      <p>Multitouches require the MultiTouchAction class. The MultiTouchAction class takes in different touchaction objects, and then performs their actions.</p>
                      <p>You can see that multitouches work very similarly to touchactions, as multitouches are made up of touchaction objects! But you can see the same chaining we used before is also implemented here.</p>
                    </aside>
                  </section>
                </section>

                <section>
                  <h3>Switching Contexts</h3>

                  <pre><code class="java" data-trim contenteditable>
                      Set&#60;String&#62; contextNames = driver.getContextHandles();

for (String contextName : contextNames){
    if (context == "NATIVE_APP")
        driver.switchTo().window("WEBVIEW_1");
    }else if(context == "WEBVIEW_1"){
        driver.switchTo().window("NATIVE_APP");
    }
}
                    </code></pre>
                  <aside class="notes">
                    <p>If you are working on hybrid testing, or if you are a testing a functionality of your native app that requires switching contexts, then you will need to know the swtichTo() function.</p>
                    <p>A context is generally going to be either a webview or your native application.</p>
                    <p>When working with a hybrid app, you can work with more than 1 webview. Generally, best practice is to get a list of the webviews that you have available, and then switch to the proper webview context by name.</p>
                  </aside>
                </section>

              <section>
                  <h3>Explicit and Implicit Waits</h3>

                  <p>Implicit Waits</p>
                  <pre>
                    <code data-trim contenteditable class="java">
                      driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
                    </code>
                  </pre>

                  <p>Explicit Waits</p>
                  <pre>
                    <code class="java" data-trim contenteditable>
//additional libs required
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

//usage
WebDriverWait wait = new WebDriverWait(driver, 10);
WebElement messageElement = wait.until(ExpectedConditions.
        presenceOfElementLocated(By.id("loginResponse")));
                    </code>
                  </pre>

                  <aside class="notes">

                    <p> There are many situations in which your test script may run ahead of the website or application you're testing, resulting in timeouts and a failing test. For example, you may have a dynamic content element that, after a user clicks on it, a loading appears for five seconds. If your script isn't written in such a way as to account for that five second load time, it may fail because the next interactive element isn't available yet. The general recommended solution for this is to use explicit waits.</p>

                    <p>Implicit and Explicit waits shouldn't be confused with TouchAction waits. the TouchAction waitAction() is actually waiting while doing an action, rather than waiting for an element to appear. It is for the touch, not the test.</p>
                  </aside>
                </section>

              <section>
                <section data-state="lab">
                  <h3>Lab 3: Action!</h3>
                  <ol>
                    <li>Restart the Appium Server.</li>
                    <li>In the application, we need to <pre style="display:inline;">click()</pre> or <pre style="display:inline;">tap()</pre> on the "Touch Paint" option.</li>
                    <li>In Local_SampleSauceTest.java, add in a <pre style="display:inline;">scrollTo()</pre> below our <pre style="display:inline;">println</pre>.</li>
                    <pre style="width:54%;"><code class="java" data-trim contenteditable>
                        driver.scrollTo("Touch Paint").click();
                    </code></pre>
                  </ol>
                  <aside class="notes">
                    <p>scrollTo() is a WebDriver action - that is, it comes from the Selenium library, and will scroll down on the apge until it finds an item that has the text string that is the argument.</p>
                    <p>If you wanted to use tap, what would we have to change or add to our script?</p>
                    <p>In this lab, our goal is to bring up the Touch Paint activity in the application, and then proceed to perform actions on the app.</p>
                  </aside>
                </section>

                <section data-state="lab">
                  <h3>Lab 3: Actions! cont.</h3>
                  <ol>
                    <li>Uncomment the three TouchAction objects (eye1, eye2, smile).</li>
                    <li>Uncomment the <pre style="display:inline;">smile.press()</pre> column of <pre style="display:inline;">moveTo()</pre> actions.</li>
                    <li>Below the TouchAction objects, insert a line that will initiate a press at x=150 and y=100 (150,200).</li>
                    <li>Add an action to release the touch at the end of the press.</li>
                    <li>Add a <pre style="display:inline;">perform()</pre> action to the end of the press and release sequence.</li>
                    <li>Repeat steps 3-5 at x=250 and y=200.</li>
                    <li>Save the script and run the test.</li>
                  </ol>
                  <aside class="notes">
                    <pre><code class="java" data-trim contenteditable>
                        eye1.press(150, 200).release().perform();
eye2.press(250, 200).release().perform();
                    </code></pre>

                    <p>The test should fail after the "Touch Paint" option has been clicked.</p>
                  </aside>
                </section>

                <section data-state="lab">
                  <h3>Lab 3: Waiting...</h3>
                  <ol>
                    <li>Restart the Appium Server.</li>
                    <li>We need to implement a wait to give the Touch Paint activity time to load.</li>
                    <li>Below the AndroidDriver object, write an explicit WebDriver wait, that will wait for 10 seconds.</li>
                    <li>Uncomment the <pre style="display:inline;">wait.until()</pre> line.</li>
                    <li>Save the script and rerun the test.</li>
                    <li>What do you see on your application screen?</li>
                  </ol>
                  <aside class="notes">
                    <p>Show where they could find the id "title" that they can use to identify the view screen that needs to load before they do the touch actions.</p>
                    <p></p>
                    <pre><code class="java" data-trim contenteditable>
                        wait.until(ExpectedConditions.visibilityOf(driver.findElementById("title")));
                    </code></pre>
                  </aside>
                </section>
              </section>

<!-- Running an Appium Script with Sauce Labs Module-->
                <section data-background="rgb(226, 35, 26)">
                  <h2>Appium Testing with Sauce Labs</h2>
                  <aside class="notes"> Finally, we run the script on Sauce Labs, and compare the methods and discuss the benefits of running on Sauce Labs</aside>
                </section>

                <section>
                  <h3>Module Objectives</h3>
                  <p>This module enables you to:</p>
                  <ul>
                    <li>Run an Appium test script on Sauce Labs</li>
                  </ul>
                  <aside class="notes"></aside>
                </section>

                <section>
                  <h3>Sauce Labs Appium Script Pre-Reqs</h3>
                  <ul>
                    <li>Use Sauce Labs storage or another online location to host the application</li>
                    <li>Sauce Labs Authentication</li>
                    <li>Desired Capabilities</li>
                  </ul>

                  <aside class="notes">
                    <p>Technically, all Appium scripts call out to a server. So you can think of them as all being remote, even if you are hosting the server on your own local machine. But if your script is going to talk to Sauce Labs, then it needs a couple of other additional items to be setup. First, we'll need to edit the "app" desired cap to point to where the application is hosted. Second, we'll need to authenticate with Sauce Labs. And lastly, we'll need to set additional desired capabilities, which defines what device and OS combination we will use, as well as the version of the OS and appium itself.</p>
                  </aside>
                </section>

                <section>
                <section>
                  <h3>Sauce Labs Authentication</h3>
                  <p>Sauce labs authentication in your test script verifies the user and records test results against that user's profile</p>

                    <li>Environment Variables</li>
                    <pre><code class="zsh" data-trim contenteditable>
                        export SAUCE_USERNAME=dragoon013
export SAUCE_ACCESS_KEY=b89b7205-3aca-4af2-9c7bded
                    </code></pre>

                    <li>Explicit Variables</li>
                    <pre><code class="java" data-trim contenteditable>
                        public static final String USERNAME = "dragoon013";
public static final String ACCESS_KEY = "b89b7205-3aca-4af2-9c7bded";
                    </code></pre>

                  <aside class="notes">
                    <p>One thing to consider when setting up your testing environment or suite, is to use Environment Variables for your credentials or explicitly state them in your script.</p>
                    <p>Having environment variables with your credentials makes tests more re-usable among other team members. For example, they may be using their own credentials to log in and it doesn't run the risk of potential exposure of credentials.</p>
                  </aside>
                </section>

                <section>
                    <h3>Sauce Labs Authentication, con't.</h3>
                    <p>Sauce Labs Authentication</p>
                    <ul>
                      <li>Username</li>
                      <li>Access Key</li>
                      <li>API URL</li>
                    </ul>
                    <div style="width:103%;">
                    <pre><code class="java" data-trim contenteditable>
                        public static final USERNAME = "dragoon013";
public static final KEY = "b89b7205-3aca-4af2-a618-9bab4c7bdebd";
public static final URL = "http://" + USERNAME
                        + ":" + KEY + "@ondemand.saucelabs.com:80/wd/hub";

@Test
public static void main(){
    DesiredCapabilities capabilities = new DesiredCapabilities();
    //additional capabilities
    AndroidDriver&#60;MobileElement&#62; driver = new AndroidDriver&#60;MobileElement&#62;
                                        (new URL(URL), capabilities);
                    </code></pre>
                    </div>
                    <aside class="notes">
                      <p>Sauce labs authenticates with the ondemand URL, which includes your user name and access key, to start an appium test session using sauce labs.</p>
                    </aside>
                  </section>
                </section>

                <section>
                  <h3>Desired Capabilities</h3> <!-- PLatform Configurator-->
                  <div style="float:left;width:50%;" class="centered">
                    <p>Required:</p>
                    <ul>
                    <li>platformName</li>
                    <li>platformVersion</li>
                    <li>deviceName</li>
                    <li>app</li>
                    <li>browserName</li>
                    <li>appiumVersion</li>
                    </ul>
                  </div>
                  <div style="float:right;width:50%;padding-right:0px;">
                    <p>Optional:</p>
                    <ul>
                    <li>deviceOrientation</li>
                    <li>appActivity</li>
                    </ul>
                  </div>
                  <div style="float:left;">
                  <pre style="box-shadow:none; width:100%;"><code class="java" data-trim contenteditable>
                      DesiredCapabilities caps = new DesiredCapabilities();
capabilities.setCapability("platformName", "Android");
capabilities.setCapability("platformVersion", "4.4");
capabilities.setCapability("browserName", "");
capabilities.setCapability("appiumVersion", "1.5.3");
capabilities.setCapability("deviceName", "Android Emulator");
capabilities.setCapability("app", "https://github.com/appium/app.apk");
                  </code></pre>
                  </div>
                  <aside class="notes">With Sauce Labs, we can set up the script to run the test on several different platforms. We aren't limited to what we have locally. If we want to indicate more platforms combinations to test on, at the same time, we typically use a framework to enable that for us.</aside>
                </section>

                <section>
                    <h3>Application Hosting</h3>
                    <ul>
                      <li>Sauce Storage</li>
                      <li>Locally hosted webserver</li>
                      <li>Remote host: AWS, DigitalOcean, Github, etc</li>
                    </ul>

                    <pre style="width:110%"><code class="zsh" data-trim contenteditable>
                        curl -u &#60;sauce_username&#62;:&#60;sauce_access_key&#62;
-X POST -H "Content-Type: application/octet-stream"
https://saucelabs.com/rest/v1/storage/&#60;sauce_username&#62;/&#60;upload_filename&#62;?overwrite=true
--data-binary @&#60;path/to/myApp.apk&#62;
                    </code></pre>

                    <pre style="width:110%"><code class="zsh" data-trim contenteditable>
                        capabilities.setCapability("app", "sauce-storage:myApp.apk");
                    </code></pre>

                    <aside class="notes">
                      <p>DEMO or Labs here. Maybe incorporate into the general lab that comes after this?</p>
                      <p><mark>After seven days, all assets are cleared from your Sauce Storage.</mark></p>
                    </aside>
                </section>

                <section>
                <section data-state="lab">
                  <h3>Lab 4: Testing Sauce Labs</h3>
                  <ol>
                    <li>Open a browser and log into <a href="https://saucelabs.com" target="_blank">saucelabs.com</a>.</li>
                    <li>Go to "My Account" from the lower left drop-up menu and copy your access key.</li>
                    <li>In the Eclipse package explorer left hand side panel, open remote-java-testng-appium-android > src/test/java > com.yourcompany > Remote_SampleSauceTest.java</li>
                    <li>Copy your access key into the script for the ACCESS_KEY variable.</li>
                    <li>Fill out the USERNAME variable with the correct value for your account.</li>
                  </ol>
                  <aside class="notes">
                    <p>We aren't going to use sauce storage in this course, so for now we are going to just point to an apk that we will grab directly from the github repository.</p>
                    <p>note that we have about the same script that we had before, but just a few more desired capabilities and additional variables and parts that we will be working with for the rest of the course.</p>

                  </aside>
                </section>

                <section data-state="lab">
                  <h3>Lab 4: The Platform Configurator</h3>
                  <ol>
                    <li>Note the DesiredCapabilities object in Remote_sampleSauceTest.java.</li>
                    <li>Open a browser to the <a href="https://wiki.saucelabs.com/display/DOCS/Platform+Configurator#/" target="_blank">Platform Configurator</a> shortcut.</li>
                    <li>Set the API to "Appium".</li>
                    <li>Set the Device to "Android Emulator Phone"</li>
                    <li>Set the Operating System to "Android 4.4".</li>
                    <li>Set the Appium Version to "1.4.16".</li>
                    <li>Set the Web or App Testing to "App Testing"</li>
                    <li>Copy and paste the missing required lines into your script.</li>
                  </ol>
                  <aside class="notes">
                    <p></p>
                  </aside>
                </section>

              <section data-state="lab">
                <h3>Lab 4: Running the Script on Sauce Labs</h3>
                <ol>
                  <li>Save and run the script.</li>
                  <li>Open the Automated Tests tab on <a href="https://saucelabs.com" target="_blank">saucelabs.com</a>.</li>
                  <li>What do you notice?</li>
                  <li>What after-test options are available?</li>
                </ol>
              </section>
</section>

<!-- Introduction to Testing Frameworks-->
                <section data-background="rgb(226, 35, 26)">
                  <h2>Introduction to Testing Frameworks</h2>
                  <aside class="notes">We'll discuss the different testing frame works here. </aside>
                </section>

                <section>
                  <h3>Module Objectives</h3>
                  <p>This module enables you to:</p>
                  <ul>
                    <li>Understand the use of Testing Frameworks</li>
                    <li>Understand the use of asserts in Appium scripts</li>
                    <li>Use a framework to record test results in Sauce Labs</li>
                  </ul>
                  <aside class="notes"></aside>
                </section>

                <section>
                  <h3>What is a Testing Framework?</h3>
                  <p></p>
                  <p>A test automation framework is a scaffold comprised of libraries, dependecies, drivers, and helper scripts that facilitate the execution of Appium test scripts.</p>
                  <ul>
                    <li>Parallelization</li>
                    <li>Assertions</li>
                    <li>Reporting</li>
                  </ul>
                  <aside class="notes">
                    <p>Ok, what does that mean? It's essentially just a bunch of additional libraries we can use in conjunction with our script for several cases:</p>
                    <li>Record your data: Frameworks often have, or can have a way for you to output the results of your test scripts for you, rather than writing them by hand</li>
                    <li>Talk to external applications: you can include external libraries in your framework to talk to and send results to places like Sauce Labs</li>
                  </aside>
                </section>

                <section>
                  <h3>Popular Frameworks</h3>
<!--
                    <div style="float:right;width:50%;padding-right:25%;"><img src="assets/images/PopularFrameworks.png" style="border:0; text-align:center; background:none;">

              </div>
-->

                  <div style="float:left;width:50%;" class="centered">
                    <p><strong>Java:</strong></p>
                    <ul>
                    <li>TestNG</li>
                    <li>JUnit</li>
                    </ul>
                    <p><strong>Ruby:</strong></p>
                    <ul>
                    <li>RSpec</li>
                    <li>Cucumber</li>
                    </ul>
                  </div>
                  <div style="float:right;width:50%;padding-right:0px;">
                    <p><strong>Python:</strong></p>
                    <ul>
                    <li>Robot</li>
                    <li>UnitTest</li>
                    <li>Nose</li>
                    </ul>
                    <p><strong>JavaScript:</strong></p>
                    <ul>
                    <li>Protractor</li>
                    <li>Nightwatch</li>
                    <li>Mocha</li>
                    </ul>
                  </div>
                  <aside class="notes">

                    <p>JavaScript:</p>
                    <li>Mocha</li>
                    <li>Karma</li>
                    <li>Jasmine</li>

                    <p>PHP:</p>
                    <li>PHPUnit</li>
                    <li>Sausage</li>
                    <li>Codeception</li>

                    <p>C#:</p>
                    <li>NUnit</li>
                    <li>MSTest</li>

                    <p>Perl:</p>
                    <li>TestMore</li>

                    <p>There are quite a few different frameworks out there. Sauce Labs has a github page with examples of scripts written using all of these frameworks.</p>

                  </aside>
                </section>

                <section>
                <section>
                  <h3>Test Driven Development vs. Behavior Driven Development</h3>
                  <p>TDD: A developer writes the test, and then writes code, and tests that code continuously, until the test passes.</p>
                  <p>BDD: A way to plan and develop code similar to TDD, but allows teams to include non-technical members when writing tests for scenarios and features</p>
                  <aside class="notes">
                    <p>In the QA/Test industry, there are a couple of different ways of thinking about how to develop applications with testing in mind. One of those is TDD, where you write a test, and then write the code until the test passes. Antoher variant is to plan the same kind of testing, but on a higher level, basically written in a more colloquial manner though.</p>
                    <p>TDD is also somewhat synonymous with "test first" development. BDD means writing tests that read like a book, almost in full sentences, so people can understand precisely what a test is trying to accomplish.</p>
                  </aside>
                </section>

                <section>
                  <h3>TDD Planning Example</h3>
                  <p>Sauce_counter() needs to count the number of sauces inputted</p>
                  <p>Pasta_counter() needs to count the number of pastas inputted</p>
                  <p>sNpComparer() needs to compare the counts and make sure that they are equal</p>
                  <aside class="notes">
                    <p>This is an example of TDD, because we have idenfitfied features of the program that need to be made, and we have a function for each one, which details very explicity what each will do.</p>
                  </aside>
                </section>


                <section>
                  <h3>BDD Planning Example</h3>

                  <p>Feature: Pasta and Sauce Matchmaker</p>
                  <p>Scenario: Some sauces</p>
                  <ul><p>Given I have 5 different kinds of Sauce</p>
                  <p>When I have 5 different kinds of Pasta</p>
                  <p>Then my chef will be happy</p></ul>

                  <aside class="notes">
                    <p>This is an example of BDD, which uses the Given, When, Then, method of planning. It details the actual goals of what the application or feature needs to accomplishes, in terms of a user story, rather than explicit functions. In this method of planning, we are making sure that the end goal or the business objective will be accomplished.</p>
                  </aside>
                </section>

                <section>
                  <h3>BDD Framework Example</h3>

                  <pre><code class="java" data-trim contenteditable>
                      @Given("^I have (\\d+) sauces for my pasta")
public void the_number_of_sauces(Int arg1) throws Throwable {
}

@When("^I have (\\d+) kinds of pasta")
public void the_number_of_pastas(Int arg1) throws Throwable {
}

@Then("^My chef will be (.*)$")
public void the_feeling_is(String arg1) throws Throwable {
}
                  </code></pre>
                  <aside class="notes">
                    <p>This is an example of BDD using CucumberJVM, a BDD testing and code writing framework. We can see how we may write out functions for the Given, When, Then, example we filled out.</p>
                  </aside>
                </section>
                </section>

                <section>
                  <h3>BDD Frameworks</h3>
                  <div style="float:left;width:50%;" class="centered">
                    <p>Python:</p>
                    <ul>
                    <li>Behave</li>
                    <li>Lettuce</li>
                      </ul>
                    <p>JavaScript:</p>
                    <ul>
                    <li>CucumberJS</li>
                    </ul>
                  </div>

                  <div style="float:right;width:50%;padding-right:0px;">
                    <p>Java:</p>
                    <ul>
                    <li>CucumberJVM</li>
                    </ul>
                    <p>Ruby:</p>
                    <ul>
                    <li>Cucumber</li>
                    </ul>
                  </div>

<!--
                  <div style="float:right;width:50%;padding-right:25%;"><img src="assets/images/BDDFrameworks.png" style="border:0; text-align:center; background:none;">
                  </div>
                  -->
              <aside class="notes">

                    <p>JavaScript:</p>
                    <li>CucumberJS</li>

                    <p>PHP:</p>
                    <li>Behat</li>

                    <p>C#:</p>
                    <li>SpecFlow</li>

                  </aside>
                </section>

                <section>
                  <section>
                    <h3>Asserts</h3>
                    <p>A testing framework directive that assumes a value to be true, and stops the test and/or throws an error if false.</p>

                    <pre><code class="java" data-trim contenteditable>
                        assertTrue(compassBtn.clickable.value);
                    </code></pre>

                    <aside class="notes">
                      <p>A common element of Appium scripts are Asserts. Asserts come with whichever testing framwork that you have decided to work with. They generally check whether a particular value is true or not. For example, if the compassBtn is not clickable, then that means the assert will fail, and the test will fail as well. It's basically the test itself. If an assert fails, that generally means the test has failed as well.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>Assert Functions</h3>
                    <div style="float:left;width:50%;" class="centered">
                      <ul>
                      <li>assertEquals</li>
                      <li>assertNull</li>
                      <li>assertSame</li>
                      </ul>
                    </div>

                    <div style="float:right;width:40%;padding-right:0px;">
                      <ul>
                        <li>assertThrows</li>
                        <li>assertTrue</li>
                        <li>assertEqualsNoOrder</li>
                      </ul>
                    </div>
                    <aside class="notes">
                      <p>There are a lot of different kinds of assertion checks that you can make. All asserts will cause a test to fail, if the check or comparison returns false. Assert equals will compare two object's values. assertNull will assert the value of an object is null. assertSame will assert two objects are the same object. and so on.</p>
                      <p>You find the full information on using asserts (with the testNG java framework) here: <a href="http://testng.org/javadocs/org/testng/Assert.html" target="_blank">assertion class details</a></p>
                    </aside>
                  </section>
                </section>

                <section data-state="lab">
                    <h3>Lab 5: Assertions</h3>
                    <ol>
                      <li>Note that the title of the Touch Paint activity is "Graphics/Touch Paint".</li>
                      <li>Write an assertEquals assertion that uses the <pre style="display:inline;">getText()</pre> function on the title WebElement object.</li>
                      <li>The assertEquals assertion should compare the value of <pre style="display:inline;">title.getText()</pre> to the expected value, namely "Graphics/Touch Paint"</li>
                      <li>Save the script and run the test.</li>

                    </ol>
                    <aside class="notes">
                      <p>We want to make sure that our script ends up where it needs to go. In order to do so, we are going search for the text descriptor for the touch Paint activity we are performing actions on.</p>
                      <p>Demo the title as it appears in the applicaition. It should say Graphics/Touch Paint. Say that the getText() will get the text value of the title. If you feel inspired, you can open the inspector on your local machine to show the them the value of text is indeed what appears as the title.</p>
                    </aside>
                  </section>

                <section>
                  <h3>Record your Results with Sauce Labs</h3>
                  <ul>
                  <li>Use the update_job method in the Sauce Labs REST API after the test runs</li>
                  <p></p>
                  <li>Use the Java Helper library; it will automatically send pass/fail results to Sauce Labs</li>
                  <p></p>
                  <li>Configure your testing framework to send results to Sauce Labs</li>

                  </ul>
                  <aside class="notes">
                    <p>So locally it's not an issue to record results, you can just print results to a file or on the console. But if we want to send details to Sauce Labs on whether a test has passed or failed, rather than just complete or not, we will have to use the Sauce Labs API or a test framework.
                    </p>
                  </aside>
                </section>

                <section data-state="lab">
                  <h3>Lab 6: Record Keeping</h3>
                  <ol>
                    <li>Open the Remote script for editing.</li>
                    <li>Uncomment the <pre style="display:inline;">id</pre> variable under the AndroidDriver line.</li>
                    <li>Uncomment the AfterMethod function at the bottom of the script.</li>
                    <li>Save the script and run the test.</li>
                    <li>Open the Remote script for editing.</li>
                    <li>Change the expected string in the assertEquals to "Graphics/Touch Banana".</li>
                    <li>Save the script and run the test.>
                    <li>Open the saucelabs.com UI. What has changed about the test results?</li>
                  </ol>
                  <aside class="notes">

                  </aside>
                </section>

                 <!--Best Practices Module-->

                 <section data-background="rgb(226, 35, 26)">
                   <h2>Testing Strategy and Best Practices</h2>
                   <aside class="notes">General best practices, testing methodology</aside>
                 </section>

                <section>
                  <h3>Module Objectives</h3>
                  <p>This module enables you to:</p>
                  <ul>
                    <li>Understand testing strategies for setting up automated testing</li>
                    <li>Label, name, and tag your tests to faciliate searching for past tests on Sauce Labs</li>
                  </ul>
                </section>

                <section>
                     <h3>Small, Atomic, and Autonomous Testing</h3>

                      <div style="float:left;width:10%;padding-right:5px;padding-bottom:10px;"><img src="assets/images/icons.png" style="border:0; text-align:center; background:none;">
                  </div>
                     <div style="padding-top:10px;"><p><strong>Small:</strong> Tests should be short and succinct.</p>
                     <p><strong>Atomic:</strong> Tests should focus on testing a single feature.</p>
                     <p><strong>Autonomous:</strong> Tests should be independent of other tests.</p>
                   </div>

                     <aside class="notes">

                       <p>Short - If you have a test suite of 100 tests running concurrently on 100 VMs, then the time it will take to run the entire suite will be determined by the longest/slowest test case. Keeping your tests small ensures that your suite will run efficiently and provide you with results faster. </p>
                       <p>Atomic - The test makes clear exactly what it is that you're testing. If the test fails, then you should also have a very clear idea of what needs to be fixed. </p>
                       <p>Autonomous - Tests should not be dependent on the results of one test to run successfully. In addition, an autonomous test should use its own data to test against, and not create potential conflicts with other tests over the same data.  </p>
                     </aside>
                </section>

                <section>
                  <section>
                     <h3>Types of Testing</h3>
                     <ul>
                       <li>Unit Testing</li>
                       <li>Functional Testing</li>
                       <li>Performance Testing</li>
                     </ul>
                     <aside class="notes">
                       <p>There are a few different kinds of testing. Sauce Labs doesn't cover them all, but it's important to know what Sauce Labs can and can't do.</p>
                     </aside>
                   </section>

                   <section>
                     <h3>Unit Testing</h3>
                     <p>Unit tests are written from a developer persepective to ensure a method or function performs a set of tasks.</p>

                     <aside class="notes">
                       <p>Unit testing focuses on testing very small parts of the application, going down to the basic functions and methods</p>
                     </aside>
                   </section>

                   <section>
                     <h3>Functional Testing</h3>
                     <p>Functional tests are written from a user perspective to test a functionality or feature of your application.</p>
                     <aside class="notes">
                       <p>Functional testing is what Sauce Labs offers to help faciliate and simplify for it's users.</p>
                     </aside>
                   </section>

                   <section>
                     <h3>Performance Testing</h3>
                     <p>Performance tests that gauge and output performance metrics for your application.</p>
                     <aside class="notes">
                       <p>Performance testing serves to answer questions such as, can your application server handle a particular load, and does it behave as expected when you push it to its limit? These types of tests are better undertaken with a testing infrastructure that has been specifically developed for performance testing, so all baseline performance metrics are well established and understood before you start the test.</p>
                       <p>Some eaxmples of performance testing helpers (similar to sauce labs):</p>

                     </aside>
                   </section>
                </section>

                <section>
                  <h3>Real vs. Simulator/Emulator Testing</h3>

                  <div style="float:left;width:50%;" class="centered">
                    <p>Real</p>
                    <ul>
                      <li>Test hardware</li>
                      <li>Test speed fluctuates</li>
                      <li>Expensive</li>
                      <li>Testing on real device</li>
                      <li>Difficult to set up</li>
                    </ul>
                  </div>

                  <div style="float:right; width:50%; padding-right:0px;">
                    <p>Simulator/Emulator</p>
                    <ul>
                      <li>Consistently reproducible</li>
                      <li>Parallelization</li>
                      <li>Less expensive</li>
                      <li>Easier to set up and do on your own</li>
                      <li>Setting language, location, turn off popup blocking, etc.</li>
                    </ul>
                  </div>
                  <aside class="notes">
                    <p>Beyond the highlevel testing types, theres what you're actually testing on. Should you test on real devices, or use a simulator/emulator?</p>
                    <p>There's a lot to be said for both!</p>
                    <p>You're going to find that your real device testing will be more expensive that testing on a simulator or emulator, whether you set it up yourself or not. It's also more difficult to set up for yourself. Of course, that can be mitigated by testing with Sauce Labs real devices. If you need to test how hardware responds or test hardware capabilities that your app uses, then real device testing is the way to go.</p>
                    <p>Testing on a Simulator or emulator is going to be easier to set up on your own though. With Sauce Labs, there's no set up at all, but also, your tests will be more reproducible. Sauce Labs spins up a completely new and clean emulator/simulator for every test you run. So you know you are starting from the same baseline everytime. With real devices, it's harder to get that clean slate every time you run a test.</p>
                    <p>There are a plethora of additional pros as well, including parallelization, cheaper cost to set up and buy, and setting particular options on a simulated device that isn't possible when testing on a real one.</p>
                  </aside>
                </section>

                <section>
                  <section>
                    <h3>Dependencies</h3>
                    <p>Hard coding dependencies to access external account or data</p>
                    <ul><li>Development and testing environments may change between the writing of your test scripts and when they run</li></ul>
                    <ul><li>Security</li></ul>
                    <aside class="notes">
                      <p>We've talked about avoiding this a bit already, but there are some other dependencies for tests that need to be considered as well.</p>
                      <p>Security we've talked about as well, we don't want to have a history of our credentials in a git history for example.</p>
                    </aside>
                  </section>

                  <section>
                    <h3>Setup</h3>
                    <p>Setup initiates <i>prerequisite</i> tasks to be taken care of before your test runs, usually setting the capabilities, configuring additional browser parameters, and more.</p>

                    <p>Example:</p>
                    <pre><code class="java" data-trim contenteditable>
                        public void setupLogin() {

    DesiredCapabilities caps = new DesiredCapabilities();
    caps.setCapability("platform", "Windows XP");
    caps.setCapability("browserName", "Chrome");
    caps.setCapability("version", "43.0");
}
                  </code></pre>
                  <aside class="notes">
                    <p>This can also include the desired capabilities and setting the WebDriver.</p>
                  </aside>
                </section>

                <section>
                  <h3>Teardown</h3>
                  <p>The teardown function includes <i>Post requisite</i> tasks that need to occur, like closing the browser, logging out, or terminating the remote session.</p>
                  <p>Example:</p>
                  <pre><code class="java" data-trim contenteditable>
                      public void tearDown(boolean testTrue) throws Exception {

    webDriver.get().quit();

    if (testTrue)) {
        r.jobPassed(id);
    } else {
        r.jobFailed(id);
    }
}
                  </code></pre>
                  <aside class="notes"></aside>
                </section>
</section>

                <section>
                  <section>
                    <h3>Object Oriented Testing</h3>
                    <p>Page Objects</p>
                     <ul>
                       <li>Code reuse across tests; reuse common element interactions</li>
                       <li>Abstraction: With product change, only change one piece of code</li>
                       <li>Cross-platform tests: abstract your application element objects that exist across iOS and Android</li>
                     </ul>
                     <aside class="notes">
                       <p>
                         Sometimes we interact with particular elements in our application repeatedly. The nature of applications is that they change over time as well. Instead of writing the same code for the same interacctions, we can add a level of abstraction with page objects.
                       </p>
                       <p>Cross-platform: allows you to use the same tests when you have an app in both ios and android.</p>
                     </aside>
                   </section>

                   <section>
                     <h3>Abstracting Page Element Locators</h3>
                     <pre><code class="jcva" data-trim contenteditable>

@FindBy(id="i_am_a_textbox")
private WebElement textInput;

/*Set Page Object Actions*/

public static GuineaPigPage getPage(WebDriver driver) {
    return PageFactory.initElements(driver, GuineaPigPage.class);
}

public void enterCommentText(String text){
    this.commentsTextAreaInput.click();
    setTextAreaInputValue(this.commentsTextAreaInput, text);
}
                     </code></pre>
                     <aside class="notes">
                       <p>In this example, we are abtracting the locating, of the textbox, and the insertion of text into it. We're making the locating and sending it inputs all in one go, all in one object.</p>
                     </aside>
                   </section>

                   <section>
                     <h3>Page Object Example: Incorrect</h3>

                     <pre><code class="java" data-trim contenteditable>
                         public class Login {

    public void testLogin() {
        driver.type("inputBox", "testUser");
        driver.type("password", "my supersecret password");
        driver.click("sign-in");
        driver.waitForPageToLoad("PageWaitPeriod");
        Assert.assertTrue(driver.isElementPresent("compose button"),
        "Login was unsuccessful");
    }
}
                     </code></pre>

                     <aside class="notes">
                       <p>This example is incorrect because it doesn't have any abstraction! Everything is done explicitly.</p>
                     </aside>
                   </section>

                   <section>
                     <h3>Page Object Example: Correct</h3>

                     <pre><code class="java" data-trim contenteditable>
                         public class TestLogin {

    public void testLogin() {
        SignInPage signInPage = new SignInPage(driver);
        HomePage homePage = signInPage.loginValidUser("userName", "password");
        Assert.assertTrue(driver.isElementPresent("compose button"),
        "Login was unsuccessful");
    }
}
                     </code></pre>
                     <aside class="notes">
                       <p>This is a good example of abstraction. We've made the signin page into its own object that we can now refer to, and do so on the next line, when we login, passing a username and password value.</p>
                     </aside>
                   </section>
                </section>

                   <section>
                     <h3>Parallelization</h3>
                     <p>Avoid dependencies between tests</p>
                     <ul><li>If you chain tests together, when one at the top fails, then they will all fail</li></ul>
                     <p>Use Frameworks</p>
                     <ul><li>Frameworks include helpful libraries and functionality that can help you make the most of parallelization</li></ul>
                     <aside class="notes">
                       <p>Running tests in parallel is the secret Sauce for accelerating your development process and creating a continuous integration/continuous delivery pipeline</p>
                       <p>One of the main features that Sauce Labs offers is parallelization, the ability to run serveral scripts at once on a variety of platforms. Since tests and commands are sent remotely, these tests take longer to run individually, but with parallelization, we can run them all at once. That is, we can start them all at the same time, which cuts down on the total time tests would normally take, saving time and money for your teams and business.</p>
                       <p>It's good to avoid dependencies between tests. This goes along with the atomic testing strategy, where we want to create autonomous tests, so that they don't depend on each other, and when one fails, then we know exactly what failed</p>
                     </aside>
                   </section>

                   <section>
                     <h3>Debugging</h3>
                     <p>What to look for:</p>
                     <ul>
                       <li>Errors in your app, Sauce Labs UI, Appium Server</li>
                       <li>Look at the test output, Appium logs, logcat, Android or iOS logs</li>
                       <li>Use the pageGetSource() command to see struture of app at that moment of error</li>
                     </ul>
                   </section>

                   <section>
                     <h3>Label Your Tests</h3>
                     <p>
                       <li>ID tests</li>
                       <li>Name tests</li>
                       <li>Apply build names to tests</li>
                     </p>

                     <pre><code class="java" data-trim contenteditable>
                         caps.setCapability("tags","tag_awesome");
caps.setCapability("build","cool_builds1");
caps.setCapability("name","Java Remote Sample Test");
                     </code></pre>
                     <p style="text-align:center;">Docs: <a href="https://wiki.saucelabs.com/display/DOCS/Test+Configuration+Options" target="_blank">Test Configuration Options</a></p>
                     <aside class="notes"></aside>
                   </section>

                   <section data-state="lab">
                     <h3>Lab 7: Labeling and Naming our Tests</h3>
                     <ol>
                       <li>Open the Remote script for editing.</li>
                       <li>Add a capability to name your test.</li>
                       <li>Add a capability to include a build number for your test.</li>
                       <li>Run the test script.</li>
                       <li>Open saucelabs.com. How does your test look different on the Automated Tests tab? The builds tab?</li>
                     </ol>
                     <aside class="notes">There's also a way to set your own build number as well</aside>
                   </section>

                   <section data-background="rgb(226, 35, 26)">
                     <h2>Additional Resources</h2>
                   </section>

                   <section>
                     <h3>Further Information</h3>
                     <li><a href="http://appium.io/slate/en/master/" target="_blank">Appium Documentation</a></li>
                     <li><a href="https://github.com/appium/appium/issues" target="_blank">Appium Issue Tracker</a></li>
                     <li><a href="https://github.com/appium/sample-code/tree/master/sample-code/examples" target="_blank">Appium Sample Test Scripts</a></li>
                     <li><a href="https://wiki.saucelabs.com/display/DOCS/The+Sauce+Labs+Cookbook+Home" target="_blank">Sauce Labs Documentation</a></li>
                     <li><a href="https://github.com/saucelabs-sample-scripts" target="_blank">Sauce Labs Sample Test Scripts</a></li>
                     <li><a href="https://github.com/saucelabs-sample-test-frameworks" target="_blank">Sauce Labs Sample Test Frameworks</a></li>
                     <aside class="notes"></aside>
                   </section>

                   <section>
                     <h3>Q&A</h3>
                     <li><a href="http://bit.ly/28NgER3" target="_blank">Survey!</a></li>
                     <li>Support: <a href="mailto:help@saucelabs.com" target="_top">help@saucelabs.com</a></li>
                     <aside class="notes"></aside>
                   </section>

            </div>

		</div>

      <script src="lib/js/jquery-2.2.4.min.js"></script>
      <script src="lib/js/head.min.js"></script>
	  <script src="js/reveal.js"></script>

	  <script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
            //width: 1200,


            controls: true,
				progress: true,
				history: true,
				center: true,
                slideNumber: true,
				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
          			{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'lib/js/jquery-2.2.4.min.js'},
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/external/external.js', condition: function() { return !!document.querySelector( '[data-external]' ); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

            Reveal.addEventListener( 'slidechanged', function( event ) {
//            console.log(event.currentSlide.getAttribute("data-state"))
// if we're on a lab slide, unhide the lab image, otherwise hide it.


            if(event.currentSlide.getAttribute("data-state") === "lab"){
                //document.getElementById("lab_pic").style.visibility="visible";


            if(document.getElementById("lab_pic").style.visibility=="visible"){
                document.getElementById("lab_pic").style.visibility="visible";
            }else{
      $("#lab_pic").css({opacity: 0.0, visibility: "visible"}).animate({opacity: 1}, 200);
            }

            }else{
               //(document.getElementById("lab_pic").style.visibility=="hidden";
               $("#lab_pic").css({opacity: 1.0, visibility: "hidden"}).animate({opacity: 0}, 200);
            }

            } );

		</script>

	</body>
</html>
